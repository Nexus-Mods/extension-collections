#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Build validation script for the collections extension
 * Checks that all required files are generated during the build process
 */

console.log('üîç Validating build outputs...');

const requiredFiles = [
  // Main outputs
  { path: 'dist/index.js', description: 'Webpack bundle' },
  
  // Copied assets
  { path: 'dist/language.json', description: 'Language file' },
  { path: 'dist/icons.svg', description: 'Icons file' },
  { path: 'dist/collectionicon.svg', description: 'Collection icon' },
  { path: 'dist/style.scss', description: 'Style file' },
  { path: 'dist/fallback_tile.png', description: 'Fallback tile image' },
];

const optionalFiles = [
  { path: 'dist/info.json', description: 'Extension info' },
  { path: 'dist/bsdiff.node', description: 'Native bsdiff module' },
];

let hasErrors = false;
let warningCount = 0;

// Check required files
console.log('\nüìã Checking required files:');
for (const file of requiredFiles) {
  const filePath = path.join(process.cwd(), file.path);
  
  if (fs.existsSync(filePath)) {
    const stats = fs.statSync(filePath);
    console.log(`‚úÖ ${file.description}: ${file.path} (${stats.size} bytes)`);
  } else {
    console.error(`‚ùå ${file.description}: ${file.path} - FILE MISSING`);
    hasErrors = true;
  }
}

// Check optional files
console.log('\nüìã Checking optional files:');
for (const file of optionalFiles) {
  const filePath = path.join(process.cwd(), file.path);
  
  if (fs.existsSync(filePath)) {
    const stats = fs.statSync(filePath);
    console.log(`‚úÖ ${file.description}: ${file.path} (${stats.size} bytes)`);
  } else {
    console.warn(`‚ö†Ô∏è  ${file.description}: ${file.path} - FILE MISSING (optional)`);
    warningCount++;
  }
}

// Validate main bundle content
console.log('\nüîç Validating bundle content:');
try {
  const mainBundle = path.join(process.cwd(), 'dist/index.js');
  if (fs.existsSync(mainBundle)) {
    const bundleContent = fs.readFileSync(mainBundle, 'utf8');
    
    // Check for common patterns that should be in the bundle
    const patterns = [
      { pattern: /module\.exports/, description: 'Module exports' },
      { pattern: /webpack/, description: 'Webpack runtime' },
    ];
    
    for (const { pattern, description } of patterns) {
      if (pattern.test(bundleContent)) {
        console.log(`‚úÖ ${description} found in bundle`);
      } else {
        console.warn(`‚ö†Ô∏è  ${description} not found in bundle`);
        warningCount++;
      }
    }
    
    // Check bundle size
    const bundleSize = bundleContent.length;
    if (bundleSize < 1000) {
      console.error(`‚ùå Bundle seems too small (${bundleSize} bytes) - possible build issue`);
      hasErrors = true;
    } else {
      console.log(`‚úÖ Bundle size looks reasonable (${bundleSize} bytes)`);
    }
  }
} catch (error) {
  console.error(`‚ùå Error validating bundle: ${error.message}`);
  hasErrors = true;
}

// Check TypeScript output
console.log('\nüîç Validating TypeScript output:');
try {
  const tsOutput = path.join(process.cwd(), 'out/index.js');
  if (fs.existsSync(tsOutput)) {
    const outputContent = fs.readFileSync(tsOutput, 'utf8');
    
    // Check for source maps
    if (outputContent.includes('//# sourceMappingURL=')) {
      console.log('‚úÖ Source maps generated');
    } else {
      console.warn('‚ö†Ô∏è  Source maps not found');
      warningCount++;
    }
    
    // Check for module structure
    if (outputContent.includes('exports.') || outputContent.includes('module.exports')) {
      console.log('‚úÖ CommonJS exports found');
    } else {
      console.error('‚ùå No exports found in TypeScript output');
      hasErrors = true;
    }
  }
} catch (error) {
  console.error(`‚ùå Error validating TypeScript output: ${error.message}`);
  hasErrors = true;
}

// Final report
console.log('\nüìä Build Validation Summary:');
if (hasErrors) {
  console.error(`‚ùå Build validation FAILED with errors`);
  process.exit(1);
} else if (warningCount > 0) {
  console.warn(`‚ö†Ô∏è  Build validation PASSED with ${warningCount} warnings`);
  process.exit(0);
} else {
  console.log('‚úÖ Build validation PASSED - all checks successful!');
  process.exit(0);
}